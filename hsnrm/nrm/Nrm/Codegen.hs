{-# LANGUAGE QuasiQuotes #-}

{-|
Module      : Nrm.Codegen
Copyright   : (c) 2019, UChicago Argonne, LLC.
License     : BSD3
Maintainer  : fre@freux.fr
-}
module Nrm.Codegen
  ( main
  , upstreamPubSchema
  , upstreamReqSchema
  , upstreamRepSchema
  , downstreamEventSchema
  , libnrmHeader
  )
where

import Codegen.CHeader
import Codegen.Dhall
import Codegen.Schema (generatePretty)
{-import Data.Aeson-}
import Data.Yaml
import Data.Default
import Dhall
import qualified Dhall.Core as Dhall
import qualified Dhall.Core
import qualified Dhall.Core as Expr (Expr (..))
import qualified Dhall.Lint as Lint
import qualified Dhall.Parser
import qualified Dhall.TypeCheck as Dhall
import NeatInterpolation
import qualified Nrm.Types.Configuration as CI (Cfg)
import qualified Nrm.Types.Manifest as MI (Manifest)
import Nrm.Types.Messaging.DownstreamEvent
import Nrm.Types.Messaging.UpstreamPub
import Nrm.Types.Messaging.UpstreamRep
import Nrm.Types.Messaging.UpstreamReq
import Protolude hiding (Rep)
import System.Directory

-- | The main code generation binary.
main :: IO ()
main = do
  putText "Codegen: nrm_messaging.h"
  writeFile "../gen/nrm_messaging.h" $ license <> libnrmHeader
  putText "Codegen: JSON schemas"
  writeFile "../gen/upstreamPub.json" upstreamPubSchema
  writeFile "../gen/upstreamReq.json" upstreamReqSchema
  writeFile "../gen/upstreamRep.json" upstreamRepSchema
  writeFile "../gen/downstreamEvent.json" downstreamEventSchema
  generateDefaultConfigurations

-- | The upstream Request schema.
upstreamReqSchema :: Text
upstreamReqSchema = generatePretty (Proxy :: Proxy Req)

-- | The upstream Reply schema.
upstreamRepSchema :: Text
upstreamRepSchema = generatePretty (Proxy :: Proxy Rep)

-- | The upstream Pub schema.
upstreamPubSchema :: Text
upstreamPubSchema = generatePretty (Proxy :: Proxy Pub)

-- | The downstream Event schema.
downstreamEventSchema :: Text
downstreamEventSchema = generatePretty (Proxy :: Proxy Event)

-- | The libnrm C header.
libnrmHeader :: Text
libnrmHeader = toHeader $ toCHeader (Proxy :: Proxy Event)

-- | A license for C headers.
license :: Text
license =
  [text|
    /*******************************************************************************
     * Copyright 2019 UChicago Argonne, LLC.
     * (c.f. AUTHORS, LICENSE)
     *
     * SPDX-License-Identifier: BSD-3-Clause
    *******************************************************************************/

    /*
     *
     *   THIS FILE WAS AUTOMATICALLY GENERATED BY NRM. DO NOT MODIFY MANUALLY.
     *
    */

  |]

data KnownType
  = Cfg
  | Manifest
  deriving (Bounded, Enum, Eq, Ord, Read, Show)

dhallType :: KnownType -> Dhall.Expr Dhall.Parser.Src a
dhallType t =
  fmap Dhall.absurd $ case t of
    Cfg -> Dhall.expected (Dhall.auto :: Dhall.Type CI.Cfg)
    Manifest -> Dhall.expected (Dhall.auto :: Dhall.Type MI.Manifest)

yamlType :: KnownType -> Value
yamlType Cfg = toJSON (def :: CI.Cfg)
yamlType Manifest = toJSON (def :: MI.Manifest)

yamlFile :: KnownType -> FilePath
yamlFile Cfg = "yaml/Cfg.yaml"
yamlFile Manifest = "yaml/Manifest.yaml"

typeFile :: KnownType -> FilePath
typeFile Cfg = "types/Cfg.dhall"
typeFile Manifest = "types/Manifest.dhall"

getDefault :: KnownType -> Dhall.Expr Dhall.Parser.Src b
getDefault x =
  Dhall.absurd <$> case x of
    Cfg -> embed (injectWith defaultInterpretOptions) (def :: CI.Cfg)
    Manifest -> embed (injectWith defaultInterpretOptions) (def :: MI.Manifest)

defaultFile :: KnownType -> FilePath
defaultFile typ = "./defaults/" <> show typ <> ".dhall"

generateDefaultConfigurations :: IO ()
generateDefaultConfigurations = do
  putText "Codegen: types."
  for_ [minBound .. maxBound] $ \t -> do
    let localDest = typeFile t
        expr = dhallType t
        dest = prefix <> localDest
    putText $ "  Writing type for " <> show t <> " to " <> toS dest
    createDirectoryIfMissing True (takeDirectory dest)
    writeOutput dest expr
  putText "Codegen: defaults."
  for_ [minBound .. maxBound] $ \defaultType -> do
    let localDest =
          defaultFile defaultType
        dest = prefix <> localDest
        expr :: Expr.Expr Dhall.Parser.Src Dhall.Core.Import
        expr = getDefault defaultType
    putStrLn $ "  Writing default for " <> show defaultType <> " to " <> dest <> "."
    createDirectoryIfMissing True (takeDirectory dest)
    writeOutput dest (Lint.lint expr)
  putText "Codegen: yaml files."
  for_ [minBound .. maxBound] $ \t -> do
    let localDest = yamlFile t
        expr = yamlType t
        dest = prefix <> localDest
    putText $ "  Writing yaml for " <> show t <> " to " <> toS dest
    createDirectoryIfMissing True (takeDirectory dest)
    writeFile dest $ "# Generated by NRM, do not modify.\n" <> toS (encode expr)
  where
    prefix = "../resources/"
